Изучите следующее улучшение алгоритма Борувки.
\begin{itemtask}
    \item Граф не перестраивается на каждой итерации, а вместо этого текущее разбиение на компоненты
        связности хранятся в лесе непересекающихся множеств. Выполнение $k$ операций над этой структурой
        данных займёт время $k \alpha(n)$, где $\alpha(n)$~--- очень медленно растущая функция (в этом
        алгоритме можно считать её константой).
    \item Рёбра, примыкающие к каждой вершине, произвольно разбиваются на некоторое количество наборов
        рёбер. Каждый набор в начале работы сортируется.
    \item Когда находятся минимальные рёбра, исходящие из каждого компонента связности, и компоненты
        связности объединяются по этим рёбрам, соответствующие им множества наборов рёбер объединяются.
    \item Возможно, рёбра, примыкающие к каждому компоненту связности, будет полезно иногда заново
        пересобирать в наборы.
\end{itemtask}
Дополните эту общую идею подробностями:
\begin{enumcyr}
    \item какого размера лучше выбрать наборы, пересобирать ли их и насколько часто?
    \item как всё это хранить?
    \item оцените время работы полученного алгоритма, как функцию от $n = |V|$ и $m = |E|$.
\end{enumcyr}

\answer{
    Разбить рёбра, примыкающие к каждой вершине, на наборы из $\log n$ рёбер, у каждой вершины будет
    $\bigO{\log n}$ наборов. Отсортировать каждый набор. Общее время сортировки наборов: $m \log \log n$,
    так как их всего $m / \log n$ и каждый сортируется за время $\log n \log \log n$.

    Завести структуру данных для непересекающихся множеств, чтобы знать, какие вершины уже объединены в
    классы эквивалентности.

    На каждом шаге для каждого компонента связности рассматриваются все наборы, каждый просматривается по
    порядку и находится наименьшее ребро, ведущее в другой компонент связности (а найденные рёбра,
    ведущие в тот же компонент связности, из набора выбрасываются). Затем берётся минимум по всем
    наборам~--- это искомое ребро. Такие рёбра находятся для каждого компонента связности, и компоненты
    связности объединяются, при этом множества их наборов также объединяются.
}